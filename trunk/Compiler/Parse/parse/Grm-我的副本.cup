package Parse;

action code {: static Symbol.Symbol sym(String s) {
	         return Symbol.Symbol.symbol(s);
	        }
	    :};

parser code  {: 
  public Absyn.Exp parseResult;
  Lexer lexer;

  public void syntax_error(java_cup.runtime.Symbol current) {
   report_error("Syntax error (" + current.sym + ")", current);
  }

  ErrorMsg.ErrorMsg errorMsg;

  public void report_error(String message, 
			   java_cup.runtime.Symbol info) {
      errorMsg.error(info.left, message);
  }

  public Grm(Lexer l, ErrorMsg.ErrorMsg err) {
    this();
    errorMsg=err;
    lexer=l;
  }
:};

scan with {: return lexer.nextToken(); :};

terminal String STRING_TEXT;
terminal Integer INTEGER;

terminal COMMA, COLON, SEMICOLON, LPAREN, RPAREN,ID, 
	LBRACK, RBRACK, LBRACE, RBRACE, DOT, PLUS, MINUS, 
	TIMES, DIVIDE, EQ, NEQ, LT, LE, GT, GE, AND, OR, 
	ASSIGN, ARRAY, IF, THEN, ELSE, WHILE, FOR, TO, DO, 
	LET, IN, END, OF, BREAK, NIL, FUNCTION, VAR, TYPE,
	REAL,STRING,INT;

non terminal program,expr,string_constant,integer_constant;
non terminal lvalue,id,expr_list,expr_seq,type_id,field_list;
non terminal declaration_list,declaration,type_declaration;
non terminal variable_declaration,function_declaration,type;
non terminal type_fields,type_field,binary_oprator,matched_stmt;
non terminal open_stmt, beta, alpha;



precedence nonassoc ASSIGN;
precedence left OR;
precedence left AND;
precedence left GT, LT, GE, LE;
precedence nonassoc EQ, NEQ;
precedence left PLUS, MINUS; 
precedence left TIMES, DIVIDE;

start with program;

program ::= expr;

expr::= string_constant
	 |	 integer_constant
	 |	 NIL
	 |	 lvalue
	 |	 MINUS expr
	 |	 expr binary_oprator expr
	 |	 lvalue ASSIGN expr
	 |	 id LPAREN expr_list RPAREN
	 |	 id LPAREN RPAREN
	 |	 type_id LBRACE field_list RBRACE
	 |	 type_id LBRACE RBRACE
	 |	 type_id LBRACK expr RBRACK OF expr
	 |	 WHILE expr DO expr
	 |	 FOR id ASSIGN TO expr DO expr
	 |	 BREAK
	 |	 LET declaration_list IN expr_seq END
	 |	 LET declaration_list IN END;



string_constant::=STRING_TEXT;

integer_constant::=INTEGER;

binary_oprator::=PLUS
			|	MINUS
			|	TIMES
			|	DIVIDE
			|	EQ
			|	NEQ
			|	GT
			|	LT
			|	GE
			|	LE
			|	AND
			|	OR;

id::=ID;

expr_seq ::= expr
		 |	 expr_seq SEMICOLON expr;

expr_list ::= expr
		 |	expr_list COMMA expr;
	
field_list::= id EQ expr
		|	field_list COMMA id EQ expr;
	
lvalue::= id
		|	lvalue DOT id
		|	lvalue LBRACK expr RBRACK;
		
declaration_list::= declaration
				|	declaration_list declaration;

declaration::=type_declaration
			|	variable_declaration
			|	function_declaration;
			
type_declaration::=TYPE type_id EQ type;

type::=	type_id
	|	LBRACE type_fields RBRACE
	|	LBRACE RBRACE
	|	ARRAY OF type_id;
	
type_fields::= type_field
			|	type_fields COMMA type_field;
			
type_field::=id COLON type_id;

type_id::= STRING
		|	INT;

variable_declaration::= VAR id ASSIGN expr
					|	VAR	id COLON type_id ASSIGN expr;
					
function_declaration::= FUNCTION id LPAREN type_fields RPAREN EQ expr
					|	FUNCTION id LPAREN RPAREN EQ expr
					|	FUNCTION id LPAREN type_fields RPAREN COLON	type_id EQ expr
					|	FUNCTION id LPAREN RPAREN COLON	type_id EQ expr;
					
					
